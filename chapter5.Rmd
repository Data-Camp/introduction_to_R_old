---
title_meta: Capítulo 5
title: Data frames
description: >-
  La mayoría de los conjuntos de datos con los que trabajará se almacenarán como
  data frames. Al final de este capítulo, podrás crear un data frame,
  seleccionar las partes que te interesen y ordenarlo de acuerdo con ciertas
  variables.
---

## ¿Qué es un data frame?

```yaml
type: NormalExercise
key: 7f95849020a2563168920409022ce7bed20835b5
xp: 100
skills:
  - 1
```

Puedes recordar del capítulo sobre matrices que todos los elementos que se colocan en una matriz deben ser del mismo tipo. En aquel entonces, tu conjunto de datos de Star Wars solo contenía elementos numéricos. 

Sin embargo, al realizar una encuesta de investigación de mercado, a menudo tienes preguntas como:

- «¿Estás casado?» o preguntas de tipo «sí/no» (`lógicas`)
- «¿Cuántos años tienes?» (`numérico`)
- «¿Qué opinas de este producto?» u otras preguntas «abiertas» (`caracteres`)
- ...

El resultado, es decir, las respuestas de los encuestados a las preguntas formuladas, es un conjunto de datos de diferentes tipos de datos. A menudo te encontrarás trabajando con conjuntos de datos que contienen diferentes tipos de datos en lugar de solo uno. 

Un marco de datos tiene las variables de un conjunto de datos como columnas y las observaciones como filas. Este será un concepto familiar para quienes provengan de diferentes paquetes de software estadístico, como SAS o SPSS.

`@instructions`
Envía la respuesta. Los datos del marco de datos de ejemplo incorporado [`mtcars`](http://www.rdocumentation.org/packages/datasets/functions/mtcars) se imprimirán en la consola.

`@hint`
¡Envía la respuesta y presencia la magia!

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Imprime el data frame incorporado en R
mtcars
```

`@solution`
```{r}
# Imprime el data frame incorporado en R
mtcars
```

`@sct`
```{r}
ex() %>% check_output_expr("mtcars", missing_msg = "No cambies nada del código, asegúrate de imprimir `mtcars`.")

success_msg("¡Buen trabajo! Continúa con el siguiente ejercicio.")
```

---

## Rápido, echa un vistazo a tu conjunto de datos (dataset)

```yaml
type: NormalExercise
key: 3d0e64ecf5f69521ee538ecc713caa02b8b0ec46
xp: 100
skills:
  - 1
```

¡Vaya, son muchos coches! 

Trabajar con conjuntos de datos de gran tamaño es frecuente en el análisis de datos. Cuando trabajas con datasets y data frames (extremadamente) grandes, tu primera tarea como analista de datos es desarrollar una comprensión clara de su estructura y elementos principales. Por lo tanto, suele ser útil mostrar solo una pequeña parte de todo el conjunto de datos. 

Entonces, ¿cómo hacer esto en R? La función [`head()`](http://www.rdocumentation.org/packages/utils/functions/head) te permite mostrar las primeras observaciones de un data frame. Del mismo modo, la función [`tail()`](http://www.rdocumentation.org/packages/utils/functions/head) imprime las últimas observaciones de tu dataset.

Tanto [`head()`](http://www.rdocumentation.org/packages/utils/functions/head) como [`tail()`](http://www.rdocumentation.org/packages/utils/functions/head) imprimen una línea superior llamada «header», que contiene los nombres de las diferentes variables del conjunto de datos.

`@instructions`
Utiliza [`head()`](http://www.rdocumentation.org/packages/utils/functions/head) en el dataset [`mtcars`](http://www.rdocumentation.org/packages/datasets/functions/mtcars) para ver el encabezado y las primeras observaciones.

`@hint`
`head(mtcars)` mostrará las primeras observaciones del data frame `mtcars`.

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Utliza head () en mtcars

```

`@solution`
```{r}
# Utliza head () en mtcars
head(mtcars)
```

`@sct`
```{r}
ex() %>% check_function("head") %>% check_arg('x') %>% check_equal(incorrect_msg = "¿Has pasado correctamente `mtcars` a la función `head()`?")

ex() %>% check_output_expr("head(mtcars)", missing_msg = "Simplemente imprime el resultado de la llamada a `head()`, sin necesidad de asignarlo a una nueva variable.")

success_msg("¡Maravilloso! Entonces, ¿qué tenemos en este dataset? Por ejemplo, `hp` representa la potencia del automóvil; el Datsun tiene la potencia más baja de los 6 automóviles que se muestran. Para obtener una descripción completa del significado de las variables, escribe `?mtcars` en la consola y lee la página de ayuda. ¡Continúa con el siguiente ejercicio!") ;
```

---

## Echa un vistazo a la estructura

```yaml
type: NormalExercise
key: f4d5b1a2c4aef31645fc7e3505e699fb6e48f3e6
xp: 100
skills:
  - 1
```

Otro método que se utiliza a menudo para obtener una visión general rápida de los datos es la función [`str()`](http://www.rdocumentation.org/packages/utils/functions/str). La función [`str()`](http://www.rdocumentation.org/packages/utils/functions/str) te muestra la estructura de tu dataset. Para un data frame, dice:

- El número total de observaciones (por ejemplo, 32 tipos de vehículos)
- El número total de variables (por ejemplo, 11 características del automóvil)
- Una lista completa de los nombres de las variables (por ejemplo, `mpg`, `cyl`...)
- El tipo de datos de cada variable (por ejemplo, `num`)
- Las primeras observaciones

La aplicación de la función [`str()`](http://www.rdocumentation.org/packages/utils/functions/str) suele ser lo primero que se hace al recibir un nuevo conjunto de datos o marco de datos. Es una excelente manera de obtener más información sobre tu dataset antes de sumergirse en el análisis real.

`@instructions`
Investiga la estructura de [`mtcars`](http://www.rdocumentation.org/packages/datasets/functions/mtcars). Asegúrate de ver los mismos números, variables y tipos de datos que se mencionaron anteriormente.

`@hint`
Usa la función [`str()`](http://www.rdocumentation.org/packages/utils/functions/str) con [`mtcars`](http://www.rdocumentation.org/packages/datasets/functions/mtcars).

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Investiga la estructura de mtcars

```

`@solution`
```{r}
# Investiga la estructura de los mtcars
str(mtcars)
```

`@sct`
```{r}
ex() %>% check_output_expr("str(mtcars)", missing_msg = "Has llamado correctamente a `str()` en `mtcars`?")

success_msg ("¡Buen trabajo! Puedes encontrar mucha información al ver el `str()` de un conjunto de datos. Continúa con el siguiente ejercicio.")
```

---

## Creación de un marco de datos

```yaml
type: NormalExercise
key: df0b89706d90526b3c0bbe15e400b74cbd900704
xp: 100
skills:
  - 1
```

Dado que usar datasets integrados no es ni la mitad de divertido que crear tus propios datasets, el resto de este capítulo se basa en un dataset desarrollado personalmente. ¡Montate en el cohete porque es hora de explorar el espacio! 

Como primer objetivo, quieres construir un data frame que describa las características principales de ocho planetas de nuestro sistema solar. Según tu buen amigo Buzz, las principales características de un planeta son:

- El tipo de planeta (terrestre o gigante gaseoso).
- El diámetro del planeta en relación con el diámetro de la Tierra.
- La rotación del planeta a través del Sol en relación con la de la Tierra.
- Si el planeta tiene anillos o no (TRUE o FALSE).

Después de realizar una investigación de alta calidad en [Wikipedia](https://en.wikipedia.org/wiki/Planet), te sientes lo suficientemente seguro como para crear los vectores necesarios: `name`, `type`, `diameter`, `rotation` y `rings`; estos ya están codificados en el editor. El primer elemento de cada uno de estos vectores corresponde a la primera observación.

Se construye un data frame con la función [`data.frame()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/data.frame). Como argumentos, pasa los vectores de antes: se convertirán en las diferentes columnas de su marco de datos. Como todas las columnas tienen la misma longitud, los vectores que pases también deberían tener la misma longitud. Pero no olvides que es posible (y probable) que contengan diferentes tipos de datos.

`@instructions`
Utiliza la función [`data.frame()`](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/data.frame) para construir un data frame. Pasa los vectores `name`, `type`, `diameter`, `rotation` y `rings` como argumentos a `data.frame()`, en este orden. Llama al data frame resultante `planets_df`.

`@hint`
Tu llamada a `data.frame()` comienza como sigue:
```
data.frame(planets, type, diameter)
```
¿Puedes terminarlo?

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Definición de vectores
name <- c("Mercury", "Venus", "Earth",
          "Mars", "Jupiter", "Saturn",
          "Uranus", "Neptune")
type <- c("Terrestrial planet",
          "Terrestrial planet",
          "Terrestrial planet",
          "Terrestrial planet", "Gas giant",
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532,
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Crea un data frame de los vectores
planets_df <-

```

`@solution`
```{r}
# Definición de vectores
name <- c("Mercury", "Venus", "Earth",
          "Mars", "Jupiter", "Saturn",
          "Uranus", "Neptune")
type <- c("Terrestrial planet",
          "Terrestrial planet",
          "Terrestrial planet",
          "Terrestrial planet", "Gas giant",
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532,
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Crea un data frame de los vectores
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sct`
```{r}
msg = "No cambies nada en la definición de los vectores. Solo agrega una llamada a `data.frame()` para crear `planets_df`."
ex() %>% check_object("name", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("type", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("diameter", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("rotation", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("rings", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("planets_df") %>% check_equal(incorrect_msg = "¿Has llamado correctamente a `data.frame()` para crear `planets_df`. Dentro de `data.frame()`, asegúrate de pasar todos los vectores order: `name`, `type`, `diameter`, `rotation` y finalmente `rings` correctamente.")


success_msg("¡Buen trabajo! El siguiente paso lógico, como ya sabes, es inspeccionar el dataframe que acabas de crear. Vamos al siguiente ejercicio.")
```

---

## Creación de un data frame (2)

```yaml
type: NormalExercise
key: c13ea421dd078030a225f49e53a8927ce8fefbe0
xp: 100
skills:
  - 1
```

El data frame `planets_df` debe tener 8 observaciones y 5 variables. Se ha puesto a disposición en el workspace, por lo que puedes utilizarlo directamente.

`@instructions`
Usa [`str()` para investigar la estructura de la nueva variable `planets_df`.

`@hint`
`planets_df` ya está disponible en tu workspace, así que `str(planets_df)` te servirá.

`@pre_exercise_code`
```{r}
# Definición de vectores
name <- c("Mercury", "Venus", "Earth",
          "Mars", "Jupiter", "Saturn",
          "Uranus", "Neptune")
type <- c("Terrestrial planet",
          "Terrestrial planet",
          "Terrestrial planet",
          "Terrestrial planet", "Gas giant",
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532,
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Crea un data frame de los vectores
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# Comprueba la estructura de planets_df
```

`@solution`
```{r}
# Comprueba la estructura de planets_df
str(planets_df)
```

`@sct`
```{r}
msg = "¡No elimines ni sobrescribas el `planets_df` data frame que ya está disponible en el workspace!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_output_expr("str(planets_df)", missing_msg = "¿Has mostrado correctamente la estructura de `planets_df`? ¡Usa `str()` para hacer esto!")

success_msg("¡Impresionante! Ahora que tiene una comprensión clara del dataset `planets_df`, es hora de ver cómo puedes seleccionar sus elementos. ¡Aprende todo sobre esto en los próximos ejercicios!")
```

---

## Selección de elementos de un data frame

```yaml
type: NormalExercise
key: 8c664726b8a173cda730cbb20a52ac1795d9a0e9
xp: 100
skills:
  - 1
```

Al igual que en los vectores y las matrices, los elementos de un marco de datos se seleccionan con la ayuda de corchetes`[ ]`. Al usar una coma, puedes indicar qué seleccionar de las filas y las columnas respectivamente. Por ejemplo:

- `my_df[1,2]` selecciona el valor de la primera fila y la segunda columna de `my_df`.
- `my_df[1:3,2:4]` selecciona las filas 1, 2, 3 y las columnas 2, 3 y 4 en `my_df`.

A veces quieres seleccionar todos los elementos de una fila o columna. Por ejemplo, `my_df[1, ]` selecciona todos los elementos de la primera fila. ¡Ahora apliquemos esta técnica en `planets_df`!

`@instructions`
- En `planets_df`, selecciona el diámetro de Mercurio: este es el valor de la primera fila y la tercera columna. Simplemente imprime el resultado.
- En `planets_df`, selecciona todos los datos de Marte (la cuarta fila). Simplemente imprime el resultado.

`@hint`
Para seleccionar el diámetro de Venus (la segunda fila), usarías `planets_df[2,3]`. Entonces, ¿qué necesitas para Mercurio?

`@pre_exercise_code`
```{r}
# Definición de vectores
name <- c("Mercury", "Venus", "Earth",
          "Mars", "Jupiter", "Saturn",
          "Uranus", "Neptune")
type <- c("Terrestrial planet",
          "Terrestrial planet",
          "Terrestrial planet",
          "Terrestrial planet", "Gas giant",
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532,
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Crea un data frame de los vectores
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# El data frame planets_df del ejercicio anterior está precargado

# Imprime el diámetro de Mercurio (fila 1, columna 3)


# Imprime los datos de Marte (cuarta fila completa)

```

`@solution`
```{r}
# El data frame planets_df del ejercicio anterior está precargado

# Imprime el diámetro de Mercurio (fila 1, columna 3)
planets_df[1,3]

# Imprime los datos de Marte (cuarta fila completa)
planets_df[4, ]
```

`@sct`
```{r}
msg = "¡No elimines ni sobrescribas el data frame `planets_df`!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_output_expr("planets_df[1,3]", missing_msg = "¿Has seleccionado e impreso correctamente el diámetro de Mercurio? Puede usar `[1,3]`.")

ex() %>% check_output_expr("planets_df[4, ]", missing_msg = "¿Has seleccionado e impreso correctamente todos los datos de Marte? Puedes usar `[4,]`.")

success_msg("¡Buen trabajo! Además de seleccionar los elementos del data frame por índice, también puedes utilizar los nombres de las columnas. Para aprender cómo hacerlo, pasa al siguiente ejercicio")
```

---

## Selección de elementos del data frame (2)

```yaml
type: NormalExercise
key: faf104fb0c605fd89f048648a4a588200bc89c76
xp: 100
skills:
  - 1
```

En lugar de utilizar números para seleccionar los elementos de un data frame, también puede utilizar los nombres de las variables para seleccionar las columnas de un marco de datos. 

Supongamos que deseas seleccionar los tres primeros elementos de la columna `type`. Una forma de hacerlo es

```
planets_df[1:3,2]
```

Una posible desventaja de este enfoque es que debes conocer (o buscar) el número de la columna `type`, lo que resulta difícil si tienes muchas variables. A menudo es más fácil simplemente hacer uso de la variable name:

```
planets_df[1:3,"type"]
```

`@instructions`
Selecciona e imprime los primeros 5 valores de la columna `"diameter"` de `planets_df`.

`@hint`
Puedes seleccionar los cinco primeros valores con `planets_df[1:5, ...]`. ¿Puedes completar en `...` el código para seleccionar solo la columna `"diameter"`?

`@pre_exercise_code`
```{r}
# Definición de vectores
name <- c("Mercury", "Venus", "Earth",
          "Mars", "Jupiter", "Saturn",
          "Uranus", "Neptune")
type <- c("Terrestrial planet",
          "Terrestrial planet",
          "Terrestrial planet",
          "Terrestrial planet", "Gas giant",
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532,
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Crea un data frame de los vectores
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# El data frame planets_df del ejercicio anterior está precargado

# Selecciona los primeros 5 valores de la columna de diámetro

```

`@solution`
```{r}
# El data frame planets_df del ejercicio anterior está precargado

# Selecciona los primeros 5 valores de la columna de diámetro
planets_df[1:5, "diameter"]
```

`@sct`
```{r}
msg = "¡No elimines ni sobrescribas el data frame `planets_df`!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_output_expr('planets_df[1:5, \"diameter\"]', missing_msg = "¿Has seleccionado correctamente los primeros cinco valores de la columna de diámetro y los has impreso? Puedes usar `[1:5, \"diameter\"]` aquí.")

success_msg("¡Bien! ¡Continúa con el siguiente ejercicio!")
```

---

## Solo planetas con anillos

```yaml
type: NormalExercise
key: e550ecb6ec45b856e6160ddfbb3d7875998e8365
xp: 100
skills:
  - 1
```

A menudo querrás seleccionar una columna completa, es decir, una variable específica de un data frame. Si deseas seleccionar todos los elementos de la variable `diameter`, por ejemplo, ambos trucos funcionarán

```
planets_df[,3]
planets_df[,"diameter"]
```

Sin embargo, hay un atajo. Si las columnas tienen nombres, puede usar el signo `$` 

```
planets_df$diameter
```

`@instructions`
- Usa el signo `$` para seleccionar la variable `rings` de `planets_df`. Almacena el vector resultante como `rings_vector`.
- Imprime `rings_vector` para ver si lo has hecho bien.

`@hint`
`planets_df$diameter` selecciona la columna `diameter` de `planets_df`; entonces, ¿qué necesitas para seleccionar la columna `rings`?

`@pre_exercise_code`
```{r}
# Definición de vectores
name <- c("Mercury", "Venus", "Earth",
          "Mars", "Jupiter", "Saturn",
          "Uranus", "Neptune")
type <- c("Terrestrial planet",
          "Terrestrial planet",
          "Terrestrial planet",
          "Terrestrial planet", "Gas giant",
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532,
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Crea un data frame de los vectores
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# planets_df está precargado en tu workspace

# Selecciona la variable rings de planets_df
rings_vector <- 
  
# Imprime rings_vector
```

`@solution`
```{r}
# planets_df está precargado en tu workspace

# Selecciona la variable rings de planets_df
rings_vector <- planets_df$rings

# Imprime rings_vector
rings_vector
```

`@sct`
```{r}
msg = "¡No elimines ni sobrescribas el data frame `planets_df`!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("rings_vector") %>% check_equal(incorrect_msg = "¿Has seleccionado correctamente la variable `rings` de `planets_df`? Usa `$rings`. Guarda el resultado como `rings_vector`.")

ex() %>% check_output_expr("rings_vector", missing_msg = "No olvides imprimir `rings_vector` después de haberlo creado!")

success_msg("¡Buen trabajo! ¡Continúa con el siguiente ejercicio y descubre otra forma de crear subconjuntos!")
```

---

## Solo planetas con anillos (2)

```yaml
type: NormalExercise
key: 1581bf4667477f274188f4f637ec7fdc73659651
xp: 100
skills:
  - 1
```

Probablemente recuerdes del instituto que algunos planetas de nuestro sistema solar tienen anillos y otros no. Lamentablemente no puedes recordar sus nombres. ¿Podría ayudarte R?

Si escribes `rings_vector` en la consola, recibirás:

```
[1] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE
```

Esto significa que las cuatro primeras observaciones (o planetas) no tienen un anillo (`FALSE`), pero las otras cuatro sí (`TRUE`). Sin embargo, no obtienes una buena visión general de los nombres de estos planetas, su diámetro, etc. Intentemos usar `rings_vector` para seleccionar los datos de los cuatro planetas con anillos.

`@instructions`
El código del editor selecciona la columna `name` de todos los planetas que tienen anillos. Adapta el código para que, en lugar de solo la columna `name`, se seleccionen todas las columnas de los planetas que tienen anillos.

`@hint`
Recuerda que para seleccionar _todas_ las columnas, ¡simplemente tienes que dejar vacía la parte de las columnas dentro de `[ ]`! Esto significa que necesitarás `[rings_vector, ]`.

`@pre_exercise_code`
```{r}
# Definición de vectores
name <- c("Mercury", "Venus", "Earth",
          "Mars", "Jupiter", "Saturn",
          "Uranus", "Neptune")
type <- c("Terrestrial planet",
          "Terrestrial planet",
          "Terrestrial planet",
          "Terrestrial planet", "Gas giant",
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532,
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Crea un data frame de los vectores
planets_df <- data.frame(name, type, diameter, rotation, rings)

rings_vector <- planets_df$rings
```

`@sample_code`
```{r}
# planets_df y rings_vector están precargados en tu workspace

# Adapta el código para seleccionar todas las columnas de los planetas con anillos
planets_df[rings_vector, "name"]
```

`@solution`
```{r}
# planets_df y rings_vector están precargados en tu workspace

# Adapta el código para seleccionar todas las columnas de los planetas con anillos
planets_df[rings_vector, ]
```

`@sct`
```{r}
msg <- "¡No elimines ni sobrescribas `planets_df` o `rings_vector`!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("rings_vector", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_output_expr('planets_df[rings_vector, ]', missing_msg = "¿Has adaptado correctamente el código para seleccionar _todas_ las columnas de los planetas que tienen anillos? Puedes usar `planets_df[rings_vector, ]`. Asegúrate de incluir la coma aquí, ¡es crucial!")

success_msg("¡Maravilloso! Esta es una solución bastante tediosa. El siguiente ejercicio te enseñará cómo hacerlo de una manera más concisa.")
```

---

## Solo planetas con anillos pero más fácil

```yaml
type: NormalExercise
key: a4a8b72a74097196eb2f8a28b056987aae834565
xp: 100
skills:
  - 1
```

Entonces, ¿qué aprendiste exactamente en los ejercicios anteriores? Seleccionaste un subconjunto de un data frame (`planets_df`) en función de si una determinada condición era verdadera o no (anillos o no), y lograste extraer todos los datos relevantes. ¡Bastante impresionante! A estas alturas, la NASA probablemente ya esté coqueteando con tu currículum ;-). 

Ahora, subamos un nivel y usemos la función [`subset()`](http://www.rdocumentation.org/packages/base/functions/subset). Deberías ver la función [`subset()`](http://www.rdocumentation.org/packages/base/functions/subset) como un atajo para hacer exactamente lo mismo que hiciste en los ejercicios anteriores. 

```
subset(my_df, subset = some_condition)
``` 

El primer argumento de [`subset()`](http://www.rdocumentation.org/packages/base/functions/subset) especifica el conjunto de datos para el que quieres un subconjunto. Al añadir el segundo argumento, le das a R la información y las condiciones necesarias para seleccionar el subconjunto correcto. 

El siguiente código dará exactamente el mismo resultado que obtuviste en el ejercicio anterior, pero esta vez, ¡no necesitarás `rings_vector`!

```
subset(planets_df, subset = rings)
```

`@instructions`
Usa `subset()` en `planets_df` para seleccionar planetas que tengan un diámetro menor que el de la Tierra. Como la variable `diameter` es una medida relativa del diámetro del planeta respecto al del planeta Tierra, su condición es `diameter < 1`.

`@hint`
`subset(planets_df, subset = ...)` casi lo resuelve; ¿puedes rellenar los `...`?

`@pre_exercise_code`
```{r}
# Definición de vectores
name <- c("Mercury", "Venus", "Earth",
          "Mars", "Jupiter", "Saturn",
          "Uranus", "Neptune")
type <- c("Terrestrial planet",
          "Terrestrial planet",
          "Terrestrial planet",
          "Terrestrial planet", "Gas giant",
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532,
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Crea un data frame de los vectores
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# planets_df está precargado en tu workspace

# Selecciona planetas con un diámetro < 1

```

`@solution`
```{r}
# planets_df está precargado en tu workspace

# Selecciona planetas con un diámetro < 1
subset(planets_df, subset = diameter < 1)
```

`@sct`
```{r}
msg = "¡No elimines ni sobrescribas el data frame `planets_df`!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex()  %>% check_correct({
  ex() %>% check_output_expr("subset(planets_df, subset = diameter < 1)", missing_msg = "¿Has especificado correctamente la parte `subset = ...` dentro de `subset()`. La condición en este caso es `diameter < 1`. Simplemente imprime el resultado")  

}, {
  ex() %>% check_function("subset") %>% check_arg('x') %>% check_equal(incorrect_msg = "El primer argumento que pases a `subset()` debe ser `planets_df`.")

})
success_msg("¡Buen trabajo! La función `subset()` no solo es más concisa, sino que probablemente también sea más comprensible para las personas que leen tu código. Continúa con el siguiente ejercicio.")
```

---

## Ordenar

```yaml
type: NormalExercise
key: 6a6fe74d3917c37380f7ac616ce084aa7814fb8a
xp: 100
skills:
  - 1
```

Hacer y crear clasificaciones es una de las actividades favoritas de la humanidad. Estas clasificaciones pueden ser útiles (las mejores universidades del mundo), entretenidas (las estrellas de cine más influyentes) o inútiles (los mejores imitadores de 007).

En el análisis de datos, puedes ordenar los datos según una determinada variable del conjunto de datos. En R, esto se hace con la ayuda de la función [`order()`](http://www.rdocumentation.org/packages/base/functions/order). 

[`order()`](http://www.rdocumentation.org/packages/base/functions/order) es una función que te proporciona la posición clasificada de cada elemento cuando se aplica a una variable, como un vector. Por ejemplo:

```
a <- c(100, 10, 1000)
order(a)
[1] 2 1 3
```

10, que es el segundo elemento de `a`, es el elemento más pequeño, por lo que 2 aparece primero en el resultado de `order(a)`. 100, que es el primer elemento de `a`, es el segundo elemento más pequeño, por lo que 1 ocupa el segundo lugar en el resultado de `order(a)`.

Esto significa que podemos usar el resultado de `order(a)` para reorganizar `a`:
    
```
a[order(a)]
[1]   10  100 1000
```

`@instructions`
Experimenta con la función [`order()`](http://www.rdocumentation.org/packages/base/functions/order) en la consola. Envía la respuesta cuando estés listo para continuar.

`@hint`
¡Juega con la función [`order()`](http://www.rdocumentation.org/packages/base/functions/order) de la consola!

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Juega con la función de pedido de la consola
```

`@solution`
```{r}
# Juega con la función de pedido de la consola
```

`@sct`
```{r}
success_msg("¡Buen trabajo! ¡Ahora usemos la función \`order () \` para ordenar tu marco de data frame!")
```

---

## Ordenar el data frame

```yaml
type: NormalExercise
key: fa88b58bf2cf62e0c181dfdcbdd2e1ddeac66807
xp: 100
skills:
  - 1
```

Muy bien, ahora que entiendes la función [`order()`](http://www.rdocumentation.org/packages/base/functions/order), hagamos algo útil con ella. Te gustaría reorganizar tu data frame de manera que comience con el planeta más pequeño y termine con el más grande. Una clasificación en la columna `diameter`.

`@instructions`
- Utiliza `order()` en `planets_df$diameter` (la columna `diameter` de `planets_df`). Guarda el resultado como `positions`.
- Ahora reorganiza `planets_df` con el vector `positions` como índices de fila dentro de los corchetes. Conserva todas las columnas. Simplemente imprime el resultado.

`@hint`
- Usa `order(planets_df$diameter)` para crear `positions`.
- Ahora, puedes usar `positions` dentro de los brackets: cuadrados: `planets_df[...]`; ¿puedes rellenar los `...`?

`@pre_exercise_code`
```{r}
# Definición de vectores
name <- c("Mercury", "Venus", "Earth",
          "Mars", "Jupiter", "Saturn",
          "Uranus", "Neptune")
type <- c("Terrestrial planet",
          "Terrestrial planet",
          "Terrestrial planet",
          "Terrestrial planet", "Gas giant",
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532,
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Crea un data frame de los vectores
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# planets_df está precargado en tu workspace

# Usa order () para crear positions
positions <-  

# Usa positions para ordenar planets_df

```

`@solution`
```{r}
# planets_df está precargado en tu workspace

# Usa order () para crear positions
positions <- order(planets_df$diameter)

# Usa positions para ordenar planets_df
planets_df[positions, ]
```

`@sct`
```{r}
msg = "¡No elimines ni sobrescribas el data frame `planets_df`!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("positions") %>% check_equal(incorrect_msg = "¿Has calculado correctamente la variable `positions`? Puedes usar `order(planets_df$diameter)`.")

ex() %>% check_output_expr("planets_df[positions,]",missing_msg = "Usa `planets_df[positions, ]` para ordenar `planets_df`; la coma entre corchetes es crucial")

success_msg("¡Maravilloso! Este ejercicio concluye el capítulo sobre data frames. Recuerda que los data frame son extremadamente importantes en R, los necesitarás todo el tiempo. Otra estructura de datos muy utilizada es la lista. ¡Este será el tema del próximo capítulo!")
```
