---
title_meta: "Kapitel\_5"
title: Dataframes
description: >-
  Die meisten Datensätze, mit denen du arbeiten wirst, werden als Dataframes
  gespeichert. Nach diesem Kapitel bist du in der Lage, Dataframes zu erstellen,
  relevante Teile von Dataframes auszuwählen und den Inhalt von Dataframes
  anhand bestimmter Variablen zu sortieren.
---

## Was sind Dataframes?

```yaml
type: NormalExercise
key: 7f95849020a2563168920409022ce7bed20835b5
xp: 100
skills:
  - 1
```

Du erinnerst dich vielleicht aus dem Kapitel über Matrizen, dass alle Elemente, die du in eine Matrix einträgst, vom selben Typ sein sollten. Damals enthielt dein Datensatz zu „Star Wars“ nur numerische Elemente. 

Bei einer Marktforschungsumfrage gibt es jedoch oft Fragen wie:

- „Sind Sie verheiratet?“ bzw. „Ja/Nein“-Fragen (`logical`)
- „Wie alt sind Sie?“ (`numeric`)
- „Was halten Sie von diesem Produkt?“ oder andere offene Fragen ohne Antwortvorgaben (`character`)
- ...

Das Ergebnis, nämlich die Antworten der Befragten auf die oben formulierten Fragen, ist ein Datensatz mit verschiedenen Datentypen. Du wirst oft mit Datensätzen arbeiten, die nicht nur einen, sondern verschiedene Datentypen enthalten. 

Ein Dataframe hat die Variablen eines Datensatzes als Spalten und die Beobachtungen als Zeilen.  Dieses Konzept wird allen vertraut sein, die mit anderen Statistik-Softwarepaketen wie SAS oder SPSS arbeiten.

`@instructions`
Sende die Antwort ab. Die Daten aus dem vorgefertigten Beispiel-Dataframe `mtcars` werden in der Konsole ausgegeben.

`@hint`
Sende die Antwort ab und lass dich überraschen!

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Print out built-in R data frame
mtcars 
```

`@solution`
```{r}
# Print out built-in R data frame
mtcars 
```

`@sct`
```{r}
ex() %>% check_output_expr("mtcars", missing_msg = "Ändern Sie nichts am Code. Stellen Sie sicher, dass Sie `mtcars` ausgeben.")

success_msg("Großartig! Fahren Sie mit der nächsten Übung fort.")
```

---

## Ein schneller Blick auf deinen Datensatz

```yaml
type: NormalExercise
key: 3d0e64ecf5f69521ee538ecc713caa02b8b0ec46
xp: 100
skills:
  - 1
```

Wow, das sind ganz schön viele Autos! 

Die Arbeit mit großen Datensätzen ist in der Datenanalyse keine Seltenheit. Wenn du mit (extrem) großen Datensätzen und Dataframes arbeitest, besteht deine erste Aufgabe als Datenanalyseprofi darin, ein Verständnis für die Struktur der Daten und die wichtigsten Elemente zu entwickeln. Deshalb ist es oft sinnvoll, nur einen kleinen Teil des gesamten Datensatzes zu zeigen. 

Wie macht man das in R? Mit der Funktion `head()` kannst du die ersten Beobachtungen eines Dataframes anzeigen. In ähnlicher Weise gibt die Funktion `tail()` die letzten Beobachtungen in deinem Datensatz aus.

Sowohl `head()` als auch `tail()` geben ganz oben eine Kopfzeile („Header“) aus, in der die Namen der Variablen in deinem Datensatz angegeben sind.

`@instructions`
Rufe `head()` für den Datensatz `mtcars` auf, um dir die Kopfzeile und die ersten Beobachtungen anzusehen.

`@hint`
`head(mtcars)` zeigt die ersten Beobachtungen im Dataframe `mtcars` an.

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Call head() on mtcars

```

`@solution`
```{r}
# Call head() on mtcars
head(mtcars)
```

`@sct`
```{r}
ex() %>% check_function("head") %>% check_arg('x') %>% check_equal(incorrect_msg = "Haben Sie `mtcars` korrekt an die `head()`-Funktion übergeben?")

ex() %>% check_output_expr("head(mtcars)", missing_msg = "Geben Sie einfach das Ergebnis des `head()`-Aufrufs aus, es ist nicht notwendig, es einer neuen Variablen zuzuweisen.")

success_msg("Wunderbar! Was haben wir also in diesem Datensatz? Zum Beispiel steht `hp` für die Pferdestärke des Autos; der Datsun hat die niedrigste Pferdestärke der 6 angezeigten Autos. Für einen vollständigen Überblick über die Bedeutung der Variablen, geben Sie `?mtcars` in die Konsole ein und lesen Sie die Hilfeseite. Fahren Sie mit der nächsten Übung fort!");
```

---

## Ein Blick auf die Struktur

```yaml
type: NormalExercise
key: f4d5b1a2c4aef31645fc7e3505e699fb6e48f3e6
xp: 100
skills:
  - 1
```

Eine weitere Methode, die oft verwendet wird, um einen schnellen Überblick über deine Daten zu bekommen, ist die Funktion `str()`. Die Funktion `str()` zeigt dir die Struktur deines Datensatzes. Für einen Dataframe liefert sie folgende Informationen:

- Gesamtzahl der Beobachtungen (z. B. 32 Fahrzeugtypen)
- Gesamtzahl der Variablen (z. B. 11 Fahrzeugmerkmale)
- Vollständige Liste der Variablennamen (z. B. `mpg`, `cyl` usw.)
- Datentyp jeder Variablen (z. B. `num`)
- Die ersten Beobachtungen

Die Nutzung der Funktion `str()` ist oft das Erste, was du tust, wenn du einen neuen Datensatz oder Dataframe erhältst. Das ist eine gute Möglichkeit, um einen Einblick in deinen Datensatz zu bekommen, bevor du mit der eigentlichen Analyse beginnst.

`@instructions`
Schau dir die Struktur von `mtcars` genau an. Vergewissere dich, dass du dieselben Zahlen, Variablen und Datentypen siehst, die im Text dieser Übung genannt werden.

`@hint`
Verwende die Funktion `str()` mit `mtcars`.

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Investigate the structure of mtcars

```

`@solution`
```{r}
# Investigate the structure of mtcars
str(mtcars)
```

`@sct`
```{r}
ex() %>% check_output_expr("str(mtcars)", missing_msg = "Haben Sie `str()` korrekt auf `mtcars` aufgerufen?")

success_msg("Gute Arbeit! Sie können viele Informationen finden, indem Sie `str()` eines Datensatzes anzeigen. Fahren Sie mit der nächsten Übung fort.")
```

---

## Dataframe erstellen

```yaml
type: NormalExercise
key: df0b89706d90526b3c0bbe15e400b74cbd900704
xp: 100
skills:
  - 1
```

Da die Verwendung vorgefertigter Datensätze nicht einmal halb so viel Spaß macht wie das Erstellen eigener Datensätze, basiert der Rest dieses Kapitels auf einem von dir erstellten Datensatz. Jetzt schnapp dir deinen Raumanzug, denn es ist Zeit für eine Tour durch den Weltraum! 

Im ersten Schritt willst du einen Dataframe erstellen, der die wichtigsten Eigenschaften von acht Planeten in unserem Sonnensystem beschreibt. Deinem guten Freund Buzz zufolge sind die wichtigsten Merkmale eines Planeten:

- Art des Planeten (Erdplanet oder Gasriese)
- Durchmesser des Planeten im Verhältnis zum Durchmesser der Erde
- Rotation des Planeten um die Sonne im Verhältnis zur Rotation der Erde
- Vorhandensein von Ringen um den Planeten (TRUE oder FALSE)

Nachdem du sorgfältig auf [Wikipedia](https://en.wikipedia.org/wiki/Planet) recherchiert hast, bist du dir sicher genug, welche notwendigen Vektoren erstellt werden müssen: `name`, `type`, `diameter`, `rotation` und `rings`; diese Vektoren sind bereits im Editor kodiert. Das erste Element in jedem dieser Vektoren entspricht der ersten Beobachtung.

Du erstellst einen Dataframe mit der Funktion `data.frame()`. Als Argumente übergibst du die Vektoren von vorhin – sie werden zu den verschiedenen Spalten deines Dataframes. Da jede Spalte dieselbe Länge hat, sollten auch die von dir übergebenen Vektoren dieselbe Länge haben. Es ist allerdings möglich (und wahrscheinlich), dass sie unterschiedliche Arten von Daten enthalten.

`@instructions`
Verwende die Funktion `data.frame()`, um einen Dataframe zu erstellen. Übergib die Vektoren `name`, `type`, `diameter`, `rotation` und `rings` als Argumente an `data.frame()`, und zwar in genau dieser Reihenfolge. Rufe den resultierenden Dataframe `planets_df` auf.

`@hint`
Dein `data.frame()`-Aufruf beginnt wie folgt:
```
data.frame(planets, type, diameter)
```
Kannst du den Code vollenden?

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03, 
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <-

```

`@solution`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sct`
```{r}
msg = "Ändern Sie nichts an der Definition der Vektoren. Fügen Sie nur einen `data.frame()`-Aufruf hinzu, um `planets_df` zu erstellen."
ex() %>% check_object("name", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("type", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("diameter", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("rotation", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("rings", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("planets_df") %>% check_equal(incorrect_msg = "Haben Sie `data.frame()` korrekt aufgerufen, um `planets_df` zu erstellen? Stellen Sie sicher, dass Sie innerhalb von `data.frame()` alle Vektoren in der richtigen Reihenfolge übergeben: `name`, `type`, `diameter`, `rotation` und schließlich `rings`.")


success_msg("Großartige Arbeit! Der logische nächste Schritt, wie Sie inzwischen wissen, ist die Inspektion des gerade erstellten Data Frames. Gehen Sie zur nächsten Übung.");

```

---

## Dataframe erstellen (2)

```yaml
type: NormalExercise
key: c13ea421dd078030a225f49e53a8927ce8fefbe0
xp: 100
skills:
  - 1
```

Der Dataframe `planets_df` sollte 8 Beobachtungen und 5 Variablen enthalten. Er wurde schon im Workspace hinterlegt, sodass du ihn direkt nutzen kannst.

`@instructions`
Benutze `str()`, um dir die Struktur der neuen Variable `planets_df` anzuschauen.

`@hint`
`planets_df` ist bereits in deinem Workspace vorhanden, also sollte `str(planets_df)` den Zweck erfüllen.

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# Check the structure of planets_df
```

`@solution`
```{r}
# Check the structure of planets_df
str(planets_df)
```

`@sct`
```{r}
msg = "Entfernen oder überschreiben Sie nicht den `planets_df` Dataframe, der bereits im Arbeitsbereich verfügbar ist!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_output_expr("str(planets_df)", missing_msg = "Haben Sie die Struktur von `planets_df` korrekt angezeigt? Verwenden Sie `str()`, um dies zu tun!")

success_msg("Super! Jetzt, da Sie ein klares Verständnis des `planets_df` Datensatzes haben, ist es an der Zeit zu sehen, wie Sie Elemente daraus auswählen können. Erfahren Sie alles darüber in den nächsten Übungen!")
```

---

## Dataframe-Elemente auswählen

```yaml
type: NormalExercise
key: 8c664726b8a173cda730cbb20a52ac1795d9a0e9
xp: 100
skills:
  - 1
```

Ähnlich wie bei Vektoren und Matrizen wählst du Elemente aus einem Dataframe mithilfe der eckigen Klammern `[ ]` aus. Durch Nutzung eines Kommas kannst du angeben, was aus den Zeilen und was aus den Spalten ausgewählt werden soll. Zum Beispiel:

- `my_df[1,2]` wählt den Wert in der ersten Zeile und zweiten Spalte in `my_df` aus.
- `my_df[1:3,2:4]` wählt die Zeilen 1, 2, 3 und die Spalten 2, 3, 4 in `my_df` aus.

Manchmal möchtest du alle Elemente einer Zeile oder Spalte auswählen. Zum Beispiel wählt `my_df[1, ]` alle Elemente der ersten Zeile aus. Wenden wir diese Technik nun auf `planets_df` an!

`@instructions`
- Wähle aus `planets_df` den Durchmesser von Merkur aus: Das ist der Wert in der ersten Zeile und dritten Spalte. Gib das Ergebnis einfach aus.
- Wähle aus `planets_df` alle Daten zum Mars aus (die vierte Zeile). Gib das Ergebnis einfach aus.

`@hint`
Um den Durchmesser der Venus (zweite Zeile) auszuwählen, bräuchtest du: `planets_df[2,3]`. Wie lautet also der Code für Merkur?

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# The planets_df data frame from the previous exercise is pre-loaded

# Print out diameter of Mercury (row 1, column 3)


# Print out data for Mars (entire fourth row)

```

`@solution`
```{r}
# The planets_df data frame from the previous exercise is pre-loaded

# Print out diameter of Mercury (row 1, column 3)
planets_df[1,3]

# Print out data for Mars (entire fourth row)
planets_df[4, ]
```

`@sct`
```{r}
msg = "Entfernen oder überschreiben Sie den `planets_df` Data Frame nicht!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_output_expr("planets_df[1,3]", missing_msg = "Haben Sie den Durchmesser für Merkur korrekt ausgewählt und ausgegeben? Sie können `[1,3]` verwenden.")

ex() %>% check_output_expr("planets_df[4, ]", missing_msg = "Haben Sie alle Daten für Mars korrekt ausgewählt und ausgegeben? Sie können `[4,]` verwenden.")

success_msg("Großartig! Neben der Auswahl von Elementen aus Ihrem Data Frame nach Index können Sie auch die Spaltennamen verwenden. Um zu erfahren, wie das geht, gehen Sie zur nächsten Übung.")
```

---

## Dataframe-Elemente auswählen (2)

```yaml
type: NormalExercise
key: faf104fb0c605fd89f048648a4a588200bc89c76
xp: 100
skills:
  - 1
```

Anstatt mithilfe von Zahlen Elemente eines Dataframes auszuwählen, kannst du auch mithilfe der Variablennamen Spalten eines Dataframes auswählen. 

Angenommen, du möchtest die ersten drei Elemente der Spalte `type` auswählen. Das kannst du zum Beispiel so tun:

```
planets_df[1:3,2]
```

Ein möglicher Nachteil dieses Ansatzes ist, dass du die Spaltennummer von `type` kennen oder nachschlagen musst. Das kann aufwendig werden, wenn du viele Variablen hast. Oft ist es einfacher, nur den Variablennamen zu verwenden:

```
planets_df[1:3,"type"]
```

`@instructions`
Wähle die ersten fünf Werte in der Spalte `"diameter"` von `planets_df` aus und gib sie einfach aus.

`@hint`
Du kannst die ersten fünf Werte mit `planets_df[1:5, ...]` auswählen. Kannst du den `...`-Platzhalter so ersetzen, dass nur die Spalte `"diameter"` ausgewählt wird?

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# The planets_df data frame from the previous exercise is pre-loaded

# Select first 5 values of diameter column

```

`@solution`
```{r}
# The planets_df data frame from the previous exercise is pre-loaded

# Select first 5 values of diameter column
planets_df[1:5, "diameter"]
```

`@sct`
```{r}
msg = "Entfernen oder überschreiben Sie den `planets_df` Data Frame nicht!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_output_expr("planets_df[1:5, \"diameter\"]", missing_msg = "Haben Sie die ersten fünf Werte aus der Durchmesserspalte korrekt ausgewählt und ausgegeben? Sie können hier `[1:5, \"diameter\"]` verwenden.")

success_msg("Gut gemacht! Weiter zur nächsten Übung!")
```

---

## Nur Planeten mit Ringen

```yaml
type: NormalExercise
key: e550ecb6ec45b856e6160ddfbb3d7875998e8365
xp: 100
skills:
  - 1
```

Oft möchtest du eine ganze Spalte, also eine bestimmte Variable aus einem Dataframe auswählen. Wenn du zum Beispiel alle Elemente der Variablen `diameter` auswählen möchtest, funktionieren die beiden folgenden Optionen:

```
planets_df[,3]
planets_df[,"diameter"]
```

Es gibt jedoch eine kürzere Option. Wenn deine Spalten Namen haben, kannst du das Zeichen `$` verwenden:

```
planets_df$diameter
```

`@instructions`
- Benutze das `$`-Zeichen, um die Variable `rings` aus `planets_df` auszuwählen. Speichere den daraus resultierenden Vektor als `rings_vector`.
- Gib `rings_vector` aus, um zu sehen, ob du es richtig gemacht hast.

`@hint`
`planets_df$diameter` wählt die Spalte `diameter` von `planets_df` aus. Welcher Code ist nötig, um die Spalte `rings` auszuwählen?

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# planets_df is pre-loaded in your workspace

# Select the rings variable from planets_df
rings_vector <- 
  
# Print out rings_vector
```

`@solution`
```{r}
# planets_df is pre-loaded in your workspace

# Select the rings variable from planets_df
rings_vector <- planets_df$rings

# Print out rings_vector
rings_vector
```

`@sct`
```{r}
msg = "Entfernen oder überschreiben Sie nicht den `planets_df` Data Frame!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("rings_vector") %>% check_equal(incorrect_msg = "Haben Sie die Variable `rings` korrekt aus `planets_df` ausgewählt? Verwenden Sie `$rings`. Speichern Sie das Ergebnis als `rings_vector`.")

ex() %>% check_output_expr("rings_vector", missing_msg = "Vergessen Sie nicht, `rings_vector` auszugeben, nachdem Sie es erstellt haben!")

success_msg("Großartig! Fahren Sie mit der nächsten Übung fort und entdecken Sie eine weitere Möglichkeit des Subsettings!")
```

---

## Nur Planeten mit Ringen (2)

```yaml
type: NormalExercise
key: 1581bf4667477f274188f4f637ec7fdc73659651
xp: 100
skills:
  - 1
```

Du erinnerst dich wahrscheinlich noch aus der Schule daran, dass einige Planeten in unserem Sonnensystem Ringe haben und andere nicht. Doch leider fallen dir ihre Namen gerade nicht ein. Kann R dir helfen?

Wenn du `rings_vector` in der Konsole eingibst, erhältst du:

```
[1] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE
```

Das bedeutet, dass die ersten vier Beobachtungen (also Planeten) keinen Ring haben (`FALSE`), aber die anderen vier schon (`TRUE`). Allerdings bekommst du keinen schönen Überblick über die Namen dieser Planeten, ihre Durchmesser und so weiter. Versuchen wir, mit `rings_vector` die Daten für die vier Planeten mit Ringen auszuwählen.

`@instructions`
Der Code im Editor wählt die Spalte `name` für alle Planeten mit Ringen aus. Passe den Code so an, dass nicht nur die Spalte `name`, sondern _alle_ Spalten für Planeten mit Ringen ausgewählt werden.

`@hint`
Zur Erinnerung: Um _alle_ Spalten auszuwählen, kannst du die Spaltenangabe innerhalb von `[ ]` einfach leer lassen. Du brauchst also `[rings_vector, ]`.

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)

rings_vector <- planets_df$rings
```

`@sample_code`
```{r}
# planets_df and rings_vector are pre-loaded in your workspace

# Adapt the code to select all columns for planets with rings
planets_df[rings_vector, "name"]
```

`@solution`
```{r}
# planets_df and rings_vector are pre-loaded in your workspace

# Adapt the code to select all columns for planets with rings
planets_df[rings_vector, ]
```

`@sct`
```{r}
msg <- "Entfernen oder überschreiben Sie `planets_df` oder `rings_vector` nicht!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("rings_vector", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_output_expr('planets_df[rings_vector, ]', missing_msg = "Haben Sie den Code korrekt angepasst, um _alle_ Spalten für die Planeten auszuwählen, die Ringe haben? Sie können `planets_df[rings_vector, ]` verwenden. Stellen Sie sicher, dass Sie das Komma hier einschließen, es ist entscheidend!")

success_msg("Wunderbar! Dies ist eine ziemlich mühsame Lösung. Die nächste Übung wird Ihnen beibringen, wie man es auf eine prägnantere Weise macht.")
```

---

## Nur Planeten mit Ringen, aber kürzer

```yaml
type: NormalExercise
key: a4a8b72a74097196eb2f8a28b056987aae834565
xp: 100
skills:
  - 1
```

Was hast du also in den vorigen Übungen gelernt? Du hast eine Teilmenge aus einem Dataframe (`planets_df`) ausgewählt, und zwar abhängig davon, ob eine bestimmte Bedingung erfüllt war oder nicht (Planet hat einen Ring oder nicht). Und du hast es geschafft, alle relevanten Daten abzurufen. Ziemlich cool! Bestimmt interessiert sich die NASA inzwischen schon für deinen CV. ;-) 

Nun gehen wir einen Schritt weiter und verwenden die Funktion `subset()`. Diese Funktion `subset()` ist quasi eine Abkürzung, um genau das zu tun, was du in den vorigen Übungen getan hast. 

```
subset(my_df, subset = some_condition)
``` 

Das erste Argument von `subset()` gibt den Datensatz an, für den du eine Teilmenge haben möchtest. Indem du das zweite Argument hinzufügst, gibst du R die notwendigen Informationen und Bedingungen, um die richtige Teilmenge auszuwählen. 

Der folgende Code liefert genau dasselbe Ergebnis wie in der vorigen Übung, nur dass du diesmal `rings_vector` nicht brauchst.

```
subset(planets_df, subset = rings)
```

`@instructions`
Benutze `subset()` mit `planets_df`, um alle Planeten auszuwählen, die einen kleineren Durchmesser als die Erde haben. Da die Variable `diameter` den Planetendurchmesser als relativen Wert im Vergleich zum Durchmesser der Erde enthält, lautet die nötige  Bedingung `diameter < 1`.

`@hint`
`subset(planets_df, subset = ...)` ist fast die Lösung. Kannst du den `...`-Platzhalter ersetzen?

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# planets_df is pre-loaded in your workspace

# Select planets with diameter < 1

```

`@solution`
```{r}
# planets_df is pre-loaded in your workspace

# Select planets with diameter < 1
subset(planets_df, subset = diameter < 1)
```

`@sct`
```{r}
msg = "Entfernen oder überschreiben Sie den `planets_df` Data Frame nicht!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex()  %>% check_correct({
  ex() %>% check_output_expr("subset(planets_df, subset = diameter < 1)", missing_msg = "Haben Sie den Teil `subset = ...` innerhalb von `subset()` korrekt angegeben? Die Bedingung in diesem Fall ist `diameter < 1`. Geben Sie einfach das Ergebnis aus.")  

}, {
  ex() %>% check_function("subset") %>% check_arg('x') %>% check_equal(incorrect_msg = "Das erste Argument, das Sie an `subset()` übergeben, sollte `planets_df` sein.")

})
success_msg("Großartig! Die `subset()`-Funktion ist nicht nur prägnanter, sondern wahrscheinlich auch verständlicher für Personen, die Ihren Code lesen. Fahren Sie mit der nächsten Übung fort.");
```

---

## Sortieren

```yaml
type: NormalExercise
key: 6a6fe74d3917c37380f7ac616ce084aa7814fb8a
xp: 100
skills:
  - 1
```

Das Erstellen von Ranglisten ist eine der Lieblingsbeschäftigungen der Menschheit. Diese Ranglisten können nützlich sein (beste Universitäten der Welt) oder unterhaltsam (einflussreichste Filmstars) oder eher sinnlos (beste 007-Doppelgänger).

Bei der Datenanalyse kannst du deine Daten anhand einer bestimmten Variablen im Datensatz sortieren. In R geschieht dies mithilfe der Funktion `order()`. 

Wenn die Funktion `order()` auf eine Variable angewendet wird, zum Beispiel auf einen Vektor, liefert sie dir die Rangfolge der einzelnen Elemente:

```
a <- c(100, 10, 1000)
order(a)
[1] 2 1 3
```

10 ist das zweite Element in `a` und auch das kleinste. Daher steht eine 2 an der ersten Stelle in der Ausgabe von `order(a)`. 100 ist das erste Element in `a` und das zweitkleinste. Also steht eine 1 an zweiter Stelle in der Ausgabe von `order(a)`.

Das bedeutet, dass wir die Ausgabe von `order(a)` verwenden können, um `a` neu zu ordnen:

    

```
a[order(a)]
[1]   10  100 1000
```

`@instructions`
Experimentiere mit der Funktion `order()` in der Konsole. Sende die Antwort ab, wenn du bereit bist, fortzufahren.

`@hint`
Experimentiere einfach mit der `order()`-Funktion in der Konsole!

`@pre_exercise_code`
```{r}
# no pec
```

`@sample_code`
```{r}
# Play around with the order function in the console
```

`@solution`
```{r}
# Play around with the order function in the console
```

`@sct`
```{r}
success_msg("Großartig! Verwenden wir nun die `order()`-Funktion, um Ihren DataFrame zu sortieren!")
```

---

## Dataframe sortieren

```yaml
type: NormalExercise
key: fa88b58bf2cf62e0c181dfdcbdd2e1ddeac66807
xp: 100
skills:
  - 1
```

Gut. Du verstehst jetzt also die Funktion `order()`. Nun lass uns etwas Nützliches mit ihr machen. Du möchtest deinen Dataframe neu sortieren, und zwar so, dass er mit dem kleinsten Planeten beginnt und mit dem größten endet. Es muss also anhand der Spalte `diameter` sortiert werden.

`@instructions`
- Rufe `order()` mit `planets_df$diameter` auf (die Spalte `diameter` von `planets_df`). Speichere das Ergebnis als `positions`.
- Sortiere nun die Werte von `planets_df` mit dem Vektor `positions` für den Zeilenindex in eckigen Klammern neu. Behalte alle Spalten bei. Gib das Ergebnis einfach aus.

`@hint`
- Verwende `order(planets_df$diameter)`, um `positions` zu erstellen.
- Jetzt kannst du `positions` in eckigen Klammern einfügen: `planets_df[...]`. Kannst du den `...`-Platzhalter ersetzen?

`@pre_exercise_code`
```{r}
# Definition of vectors
name <- c("Mercury", "Venus", "Earth", 
          "Mars", "Jupiter", "Saturn", 
          "Uranus", "Neptune")
type <- c("Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", 
          "Terrestrial planet", "Gas giant", 
          "Gas giant", "Gas giant", "Gas giant")
diameter <- c(0.382, 0.949, 1, 0.532, 
              11.209, 9.449, 4.007, 3.883)
rotation <- c(58.64, -243.02, 1, 1.03,
              0.41, 0.43, -0.72, 0.67)
rings <- c(FALSE, FALSE, FALSE, FALSE, TRUE, TRUE, TRUE, TRUE)

# Create a data frame from the vectors
planets_df <- data.frame(name, type, diameter, rotation, rings)
```

`@sample_code`
```{r}
# planets_df is pre-loaded in your workspace

# Use order() to create positions
positions <-  

# Use positions to sort planets_df

```

`@solution`
```{r}
# planets_df is pre-loaded in your workspace

# Use order() to create positions
positions <- order(planets_df$diameter)

# Use positions to sort planets_df
planets_df[positions, ]
```

`@sct`
```{r}
msg = "Entfernen oder überschreiben Sie den `planets_df` Data Frame nicht!"
ex() %>% check_object("planets_df", undefined_msg = msg) %>% check_equal(incorrect_msg = msg)

ex() %>% check_object("positions") %>% check_equal(incorrect_msg = "Haben Sie die Variable `positions` korrekt berechnet? Sie können `order(planets_df$diameter)` verwenden.")

ex() %>% check_output_expr("planets_df[positions,]",missing_msg = "Verwenden Sie `planets_df[positions, ]`, um `planets_df` zu sortieren; das Komma innerhalb der eckigen Klammern ist entscheidend!")

success_msg("Wunderbar! Diese Übung schließt das Kapitel über Data Frames ab. Denken Sie daran, dass Data Frames in R äußerst wichtig sind, Sie werden sie ständig benötigen. Eine weitere sehr oft verwendete Datenstruktur ist die Liste. Dies wird das Thema des nächsten Kapitels sein!")
```
